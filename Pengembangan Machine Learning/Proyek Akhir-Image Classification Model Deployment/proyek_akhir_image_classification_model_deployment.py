# -*- coding: utf-8 -*-
"""Proyek Akhir : Image Classification Model Deployment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KwzMxItsvG8yVjKzGujSP9ujgaN-oe3N

Nama : Nabilah Sofieyanti

Proyek Akhir : Image Classification Model Deployment

Belajar Pengembangan Machine Learning

## Import library
"""

# Commented out IPython magic to ensure Python compatibility.
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator

import zipfile,os

import numpy as np
from google.colab import files
from tensorflow.keras.preprocessing import image
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
# %matplotlib inline

import pathlib

"""## Load data"""

local_zip = '/content/Intel_image.zip'
zip_ref = zipfile.ZipFile(local_zip, 'r')
zip_ref.extractall('/content')
zip_ref.close()

base_dir = '/content/Intel_image/seg'

os.listdir(base_dir)

"""## Split data"""

train_datagen = ImageDataGenerator(
                    rescale=1./255,
                    rotation_range=20,
                    horizontal_flip=True,
                    shear_range=0.2,
                    fill_mode= 'nearest',
                    validation_split=0.2)

val_datagen = ImageDataGenerator(
                    rescale=1./255)

train_generator = train_datagen.flow_from_directory(
        base_dir,  
        target_size=(150, 150),
        shuffle=True,
        subset='training',
        class_mode='categorical')

validation_generator = train_datagen.flow_from_directory(
        base_dir,
        target_size=(150, 150),
        subset='validation',
        class_mode='categorical')

"""## Modelling and compile"""

model = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(32, (3,3), activation='relu', input_shape=(150, 150, 3)),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Conv2D(128, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Conv2D(512, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(512, activation='relu'),
    tf.keras.layers.Dense(6, activation='softmax')
])

model.summary()

model.compile(loss='categorical_crossentropy',
              optimizer=tf.optimizers.Adam(),
              metrics=['accuracy'])

"""## Callbacks"""

#callbacks
class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('accuracy')>0.85) and (logs.get('val_accuracy')>0.85):
      print("\nAkurasi telah mencapai 85%, stop training!")
      self.model.stop_training = True
callbacks = myCallback()

"""## Training model"""

num_epochs = 30
history = model.fit(train_generator, 
                    epochs = num_epochs, 
                    validation_steps = 5,
                    validation_data=validation_generator,
                    verbose=2,
                    callbacks=[callbacks]
                    )

"""## Plot"""

plt.style.use("ggplot")
plt.figure(figsize=(10, 5))
plt.plot(history.history["loss"], label="training")
plt.plot(history.history["val_loss"], label="validation")
plt.title("Loss")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()

plt.figure(figsize=(10, 5))
plt.plot(history.history["accuracy"], label="training")
plt.plot(history.history["val_accuracy"], label="validation")
plt.title("Accuracy")
plt.xlabel("Epoch")
plt.ylabel("Accuracy")
plt.legend()

"""## Predict"""

print(train_generator.class_indices)

uploaded = files.upload()

for fn in uploaded.keys():
 
  path = fn
  img = image.load_img(path, target_size=(150,150))

  imgplot = plt.imshow(img)
  x = image.img_to_array(img)
  x = np.expand_dims(x, axis=0)
  images = np.vstack([x])

  classes = model.predict(images, batch_size=10)
  output_class = np.argmax(classes)
  print(fn)
  if output_class==0:
    print('Buildings')
  elif output_class==1:
    print('Forest')
  elif output_class==2:
    print('Glacier')
  elif output_class==3:
    print('Mountain')
  elif output_class==3:
    print('Sea')
  else:
    print('Street')

"""## Save model"""

export_dir = 'saved_model/'
tf.saved_model.save(model, export_dir)

converter = tf.lite.TFLiteConverter.from_saved_model(export_dir)
tflite_model = converter.convert()

tflite_model_file = pathlib.Path('vegs.tflite')
tflite_model_file.write_bytes(tflite_model)